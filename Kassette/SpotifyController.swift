//
//  SpotifyController.swift
//  Kassette
//
//  Created by Vish on 8/1/24.
//  Generated by Claude on 8/1/24
//

import Foundation
import SpotifyiOS
import WidgetKit

class SpotifyController: NSObject, ObservableObject {
    static let shared = SpotifyController()
    
    @Published var isAuthorized = false
    @Published var currentTrack: String?
    
    private let clientID = "415ea4169ce14173be924fb9552db003"
    private let redirectURI = "Kassette://callback"
    
    private var configuration: SPTConfiguration
    private var appRemote: SPTAppRemote
    
    override init() {
        self.configuration = SPTConfiguration(clientID: clientID, redirectURL: URL(string: redirectURI)!)
        self.appRemote = SPTAppRemote(configuration: configuration, logLevel: .debug)
        super.init()
        
        // toggle playback observer (added)
        NotificationCenter.default.addObserver(self, selector: #selector(handleTogglePlayback), name: Notification.Name("TogglePlayback"), object: nil)
    }
    
    @objc func handleTogglePlayback() {
        print("handleTogglePlayback called in OBJECTIVE C!!")
        togglePlayPause()
    }
    

    func authorize() {
        print("Starting authorization process...")
        let scope = "user-read-private,user-read-email,user-read-playback-state,app-remote-control"
        let urlString = "spotify-action://authorize?client_id=\(clientID)&redirect_uri=\(redirectURI)&scope=\(scope)&response_type=token"
        
        if let authURL = URL(string: urlString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "") {
            print("Attempting to open auth URL: \(authURL)")
            UIApplication.shared.open(authURL) { success in
                if success {
                    print("Opened auth URL successfully")
                } else {
                    print("Failed to open auth URL")
                    self.authorizeThroughBrowser()
                }
            }
        } else {
            print("Failed to create auth URL")
            self.authorizeThroughBrowser()
        }
    }

    private func authorizeThroughBrowser() {
        let scope = "user-read-private,user-read-email,user-read-playback-state,app-remote-control"
        let urlString = "https://accounts.spotify.com/authorize?client_id=\(clientID)&response_type=token&redirect_uri=\(redirectURI.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) ?? "")&scope=\(scope)&show_dialog=true"
        
        if let authURL = URL(string: urlString) {
            UIApplication.shared.open(authURL)
        }
    }
    
    func handleCallback(url: URL) {
        print("Handling callback URL: \(url)")
        
        // Extract access token from URL fragment
        if let fragment = url.fragment,
           let accessToken = fragment.components(separatedBy: "&")
               .first(where: { $0.starts(with: "access_token=") })?
               .components(separatedBy: "=")[1] {
            
            print("Received access token")
            appRemote.connectionParameters.accessToken = accessToken
            self.isAuthorized = true
            self.connect()
        } else {
            print("No access token received")
        }
    }
    
    func connect() {
        print("Attempting to connect to Spotify")
        appRemote.delegate = self
        appRemote.connect()
    }
    
    func fetchImageData(from url: URL?) -> Data? {
        guard let url = url else { return nil }
        // todo: make this async,,, lols
        guard let data = try? Data(contentsOf: url) else { return nil }
        return data
    }
    
    func getCurrentTrack() {
        print("Getting current track")
        appRemote.playerAPI?.getPlayerState { [weak self] (result, error) in
            if let error = error {
                print("Error getting player state: \(error.localizedDescription)")
                return
            }
            
            if let playerState = result as? SPTAppRemotePlayerState {
                let track = playerState.track
                let trackName = track.name
                let artistName = track.artist.name
                let albumName = track.album.name
                // todo: err handling here lols
                let trackURL: URL = URL(string: "https://i.scdn.co/image/" + track.imageIdentifier.split(separator: ":").last!)!
            
                self?.currentTrack = "\(trackName) by \(artistName)"
                print("Current track: \(trackName) by \(artistName)")
                
                let trackInfo = TrackInfo(
                    trackName: track.name,
                    artistName: track.artist.name,
                    trackImageData: self?.fetchImageData(from: trackURL),
                    isPlaying: !playerState.isPaused
                )
                SpotifyManager.shared.saveTrackInfo(trackInfo)
            } else {
                self?.currentTrack = "No track playing"
                SpotifyManager.shared.saveTrackInfo(
                    TrackInfo(
                        trackName: "No track",
                        artistName: "",
                        trackImageData: nil,
                        isPlaying: false)
                )
                print("No track playing")
            }
        }
    }
}

extension SpotifyController: SPTAppRemoteDelegate {
    func appRemoteDidEstablishConnection(_ appRemote: SPTAppRemote) {
        print("Connected to Spotify")
        print("Claude said I should attach a delay here")
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) { [weak self] in
            self?.getCurrentTrack()
        }
    }
    
    func appRemote(_ appRemote: SPTAppRemote, didFailConnectionAttemptWithError error: Error?) {
        print("Failed to connect to Spotify: \(error?.localizedDescription ?? "unknown error")")
    }
    
    func appRemote(_ appRemote: SPTAppRemote, didDisconnectWithError error: Error?) {
        print("Disconnected from Spotify: \(error?.localizedDescription ?? "unknown error")")
    }
    
    func togglePlayPause() {
        print("togglePlayerPause called")
        if let isPlaying = SpotifyManager.shared.getTrackInfo()?.isPlaying {
            if isPlaying {
                appRemote.playerAPI?.pause { [weak self] _, error in
                    if let error = error {
                        print("Error pausing track: \(error)")
                    } else {
                        self?.getCurrentTrack()
                    }
                }
            } else {
                appRemote.playerAPI?.resume { [weak self] _, error in
                    if let error = error {
                        print("Error resuming track: \(error)")
                    } else {
                        self?.getCurrentTrack()
                    }
                }
            }
        }
    }
}
